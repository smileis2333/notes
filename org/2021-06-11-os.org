#+TITLE: 操作系统
#+STARTUP: indent
* 内核分类
** hrbrid
*** Darwin-XNU
*** NT
** 宏内核
Linux
** 微内核
尽可能内核保持精简，其他的必要模块拆分独立出去，通过消息来实现调用
* 内存管理演化
单道程序 --> 直接访问

多道程序 --> 多程序并发，为了让程序不直接访问到物理内存或者说彼此造成冲突，需要做一层隔离
** 分页模型
虚拟地址的总额对应物理地址的总额，在程序链接时产生

1. 以一对一的地址映射来做，假设以虚拟地址作为物理地址索引来找具体的物理地址，即物理内存作为一个超大数组，里面每个元素存放了一个对应的物理地址，虚拟地址换成物理地址就是以虚拟地址对应的下标来做映射
不可行，因为内存已经完全被作为地址转换关系表用完了，因为粒度太小
2. 如果让关联表尽可能小点呢，分块，让映射都是基于一块一块，那么只要虚拟地址和物理地址的块大小一样，关联的地址，一个就可以对应一坨映射关系(分页模型)

[[file:~/study-record/img/mmu.png][mmu]] 图示
*** MMU页表
存在与内存中，
一个顶级页目录，多个中级页目录，最后才是页表
而虚拟地址按照规范，每一块的信息作为对应的查询位置
[[file:~/study-record/img/mmu_page_table.png][mmu页表]]
**** TODO 原因
* Cache
1. 缓解CPU与内存由于制造工艺导致量级差距
2. 本质是对于程序运行规律的一种假设，即程序的局部性原理
** level
*** 1级缓存
   核心专属，分为 指令Cache 和 数据Cache
*** 2级缓存
核心专属
*** 3级缓存
全核心共享
** protocol
*** MESI 协议
[[file:~/study-record/img/os_cache_modify.png][(M)odify]]
[[file:~/study-record/img/os_cache_exclusive.png][(E)xclusive]]
[[file:~/study-record/img/os_cache_share.png][(S)hare]]
(I)nvalid
* 同步原语
** 原子变量
** 关中断
防止断码块中途被打断，单核CPU可以这么搞
*** v1 非嵌套代码
直接开关中断即可
*** v2 压栈确认是否开启
即到最外一层才可以成功开启中断，防止内外层开启导致的信息不一致
** 自旋锁
由硬件提供了最基本的原子指令，用于确保读取锁变量的过程中是原子性的


如果一个CPU获取自旋锁后发生中断，中断代码里也尝试获取自旋锁，那么自旋锁永远不会被释放，发生死锁。
[[file:~/study-record/img/spinlock_flow.png][spin lock flow]]
** 信号量
* 编译过程
HelloWorld.c     -->    HelloWorld.i --> HelloWorld.s   -->    HelloWorld.o     -->      HelloWorld可执行文件
                                                               其他别的库
            (GCC预处理器)         (GCC编译器)          （GCC汇编器）            (GCC链接器)
* 发展过程
** 图灵机
无限长的纸带，上面有无数格子，格子上可以存储信息
读头，可以移动，读取纸带格子内容，根据内容的类型做处理，如现有四个格子，前两个是 1，第3个是 + 号，读到+的时候，就把前两个加完放到第四个格子
** 冯诺依曼体系结构
* 汇编
call在跳转前在当前IP寄存器的地址压入栈，在ret的时候重新出栈接着执行
* bootloader
** grub
** grub2
* 显卡
** VESA
把屏幕分24行，每行80个字符，把其各个的位置映射到0xb8000 地址开始的内存中，两个字节对应的一个字符，第一个是ASCII码，第二个是颜色值
关键：
1. 开发者不必显卡具体的工作细节，开发者提供数据，经由显卡内部转换，最后在屏幕，控制输出的信号的点阵完全由显卡自身进行转换
2. 该模式旨在提供最低情况的显示效果，即亮机
* CPU模式
** 实模式
真实指令，真实地址

访问内存
CS段寄存器

** 保护模式
** 长模式