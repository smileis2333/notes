#+TITLE: csrf
#+STARTUP: indent
* 第一类，设计有问题
用户访问siteA, 生成对应cookie
恶意用户诱导用户访问siteB，打开页面的时候加载脚本，用js进行请求(比如转账到具体用户)
xss主要是影响用户体验，整一些脏数据，让页面的显示出问题，csrf一般配合xss攻击用
Eg:
如打开银行转账，如果设计存在缺陷，使用get进行转账
不小心打开恶意网站B，该网站知道了银行的设计缺陷，整个通用的转账链接，主要被打开窗口，请求就会发送，cookie自动带
* 第二类，flow跑不掉(但是概率极低)
如Oauth2，以拉勾网为例
1. 登录账号
2. 确定自己没绑微信，并在PC点击绑定，Oauth2 flow开始
3. 扫码完后，302 code回调给拉钩服务器，拉钩服务器code 换 token，在换用户信息
4. 根据当前session对应的账号，设置进系统上下文，用户看到自己的绑定账号


攻击：
1. 恶意用户如果第三步302出来的地址，用抓包拦截，并不往下走，然后把那条链接通过邮件乱发来诱导他人点击
2. 被诱导用户进行了点击，此时自己的账号绑定了恶意账号的微信账号，恶意用户可以通过微信来登录被诱导的用户

上述情况很难实现，因为钓鱼也需要时间，但是Oauth2提供了额外的机制来避免，即state参数，上述的问题出现是由于无法确认当前session是否是正确的，如果在服务器启动重定向的时候写一个参数在session内，并且回调的时候检查该参数是否对应，即可确定开始和结束的用户是一致的



